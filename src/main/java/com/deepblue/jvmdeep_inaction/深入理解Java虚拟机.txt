-------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------  第一章 走进Java  -----------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
1、编译自己的JDK源码, 这个在HotSpot实战中已经编译过了, 参考 openjdk7和jdk6最终编译过程.txt

书籍来源地址:
http://pan-yz.chaoxing.com/share/info/b7b7702a30a2d8ac 密码: dmm16d


-------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------  第二章 Java内存区域与内存溢出异常  -----------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
1、运行时数据区
    内存区域划分:
        本地方法栈、 Java虚拟机栈(PC[program counter register] + 栈帧)、 方法区、 堆 等区域的划分

    Visual Stack:
        存放内容: 局部变量表, 操作数栈, 动态链接, 方法的返回地址 等
        PC寄存器: 其中只有程序计数器 是没有任何OutOfMemoryError 的唯一一块区域, 每个线程都有自己的程序计数器和栈帧, 并且程序计数器只记录所属线程的指令信息, 如果当前的是Native的方法, 则硬件PC计数器则起作用, 线程PC计数器中记录的指令为null
        可能抛出的异常: 当栈帧分配的深度超过jvm虚拟规定的最大虚拟栈深度时, 就会抛出StackOverflowError, 如果无法申请到足够的内存时 则抛出OutOfMemoryError 异常

    Native Stack:
        为执行本地方法提供的一块内存区域, 这块区域和Visual Stack 十分相似, 只是操作的API对象是本地方法库中的方法, 这部分代码是C++代码
        可能抛出的异常: StackOverflowError, OutOfMemoryError

    Heap区域:
        Heap区往下接着分: 新生代 + 老年代; 新生代又分为: Eden区 + From Survivor + To Survivor 空间;
        Heap区中可能会存在加速分配的缓冲区, 这块区域是被所有线程共享的, 这块区域叫做 Thread Local Allocate Buffer, 简称TLAB
        -Xmx:   表示最大堆内存
        -Xms:   表示最初堆内存
        -Xmn:   表示新生代大小
        可能出现的异常: 无法满足内存需求时就会抛出 OutOfMemoryError 异常

    方法区:
        存放内容: 类相关的信息, 常量等
        可能出现的异常: 无法满足内存需求时就会抛出 OutOfMemoryError 异常
        VMOption: -XX: MaxPermSize=
        可能出现的异常: 无法满足内存需求时就会抛出 OutOfMemoryError 异常

    直接内存:
        虽然直接内存没有在java虚拟机规范中提到, 但是也会受到实际物理内存的限制, 一旦上面提到的JVM内存综合一旦超过时机物理内存, 这块区域就没有分配空间
        因此一旦使用Native 和 Heap进行交换 使用到直接内存, 就会抛出 OutOfMemoryError 异常

2、对象的创建
    内存分配:
        对象的创建是在堆中分配内存的, 对象在堆中分配内存的方式分为2种: 指针碰撞分配内存 和 空闲列表分配内存
        指针碰撞分配方式: 属于整块内存分配方式
        空闲列表分配方式: 属于散列内存分配方式
        采用哪种方式分配内存 看的是 如何进行内存的垃圾回收, 这和垃圾回收器回收内存的方式有直接关系:
            使用 Serial, ParNew 带有 Compact 压缩内存作用的垃圾回收器, 则会使用指针碰撞方法分配内存
            使用 CMS 这种基于MarkSweep算法的垃圾回收器分配内存时, 则会使用空闲列表方式来分配内存
        多线程分配内存时的问题, 当线程A使用指针P分配内存, 如果线程B也在使用指针P分配内存, 这样指针P的移动就会出现并发问题, 为了解决这个问题提出了2种方案:
            使用CAS方式保证多线程分配内存的准确性
            使用TLAB方式, 为每个线程都提供Thread Local Allocation Buffer, 直到TLAB空间使用完成, 再次分配TALB时加锁实现, 要使用VMOption: -XX:+UseTLAB

    对象初始化:
        在为对象分配完内存后, 对内存进行初始化, 除了对象头之外进行零初始化(在new 指令后进行init指令的执行), 这两个步骤完成后按照程序员的意愿进行初始化!



3、对象的内存布局
    对象的组成: 在HotSpot中实例的组成部分主要有两部分: 对象头、实例数据; 在深入理解Java虚拟机中对象的组成部分分为: 对象头、实例数据、对齐填充
        对象头
            对象头的组成  MarkWord + 元数据指针 + (数组包含_length)
            对象头有两种  instanceOopDesc、arrayOopDesc; instanceOopDesc 和 arrayOopDesc 中的Mark Word 中存放了一些对象的状态, 具体参考HotSpot中的MarkWord的状态
            元数据指针　  指定当前实例内存归属哪个类

        实例数据:
            实例数据也需要内存, 内存分配按照的顺序是什么? 字段分配内存的顺序受什么的影响?
            默认的顺序: long/doubles  ints  shorts/chars  bytes/boolean  oops; VMOption参数 FieldsAllocationStyle 和 CompactFields

4、对象的访问定位
    在HotSpot中的定位对象的方式有两种: 1、句柄池 2、直接查找

                                    |<---- 句柄池 ---->|
    栈帧中   参数引用 / 变量引用  --->  堆区 元数据类型 指针 ---> 方法区  某个类
                            |
                            |  --->  堆区 实例的数据 指针 ---> Heap区 某块区域

    栈帧中   参数引用 / 变量引用  --->  堆区 对象头  --->  方法区 某个类

    查找对象的方式通过 句柄池 间接寻找 [句柄池包含 元数据指针 + 实例数据指针];
    查找对象的方式通过 对象头 直接寻找 [对象头包含 元数据指针 + 实例数据]


5、OOM 异常的展示和实战
    什么是内存泄漏: 所谓泄漏类似于杯子无论 满不满都能漏水, 这种情况造成内存无法回收叫内存泄漏! 既然泄漏了无法回收这时就需要找GCRoots的可达性来分析了!
    什么事内存溢出: 所谓溢出类似于杯子满了 造成的谁溢出, 这种情况叫内存溢出!

    堆溢出 测试 HeapOOM      在java虚拟机规范中规定 如果超过堆内存大小将会报出 OutOfMemoryError 错误!
    栈溢出 测试 StackSOF, StackOOM  经验证无论哪种方式是java 栈内存溢出都会报出 StackOverflowError 错误!

    方法区和运行时常量池的溢出 查看 MethodAreaOOM, RuntimeConstantPoolOOM 类中的测试, 此处注意String 中 intern()方法的用处, 运行时常量池中的引用的获取

    直接内存溢出 查看 DirectMemoryOOM 类中的测试 直接内存不属于Java虚拟机直接管理的运行时数据内存, 但在堆区中可以通过DirectByteBuffer 来引用直接内存中的这块区域
                    如果不设置-XX:MaxDirectMemory=*M, 则默认值和 -Xmx的大小是一致的!


-------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------  第三章 垃圾回收器和内存分配策略  -------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
官方文档查询地址: https://docs.oracle.com/search/ 内部输入: Garbage Collection 都可以搜索到, 并且这里也下载了一份 垃圾回收的官方文档


思维模型:   谁[1] 在什么地方[2] 在什么时间点[3] 用什么方法[4] 对 谁[5] 干了些什么[6]?
[1]: 垃圾收集器
[2]: Java虚拟机栈、本地方法栈、方法区、堆区、直接内存
[3]: 安全点 或 安全区
[4]: 标记-清除算法 标记-复制算法 标记-整理算法
[5]: Java虚拟机栈、本地方法栈、方法区、堆区、直接内存 中的死对象
[6]: 进行清除


垃圾回收的背景:
    回到半个世纪以前, 垃圾回收一直在被开发人员所考虑着, 在上一章中了解到 本地方法栈, Java虚拟机栈, 程序计数器, 方法区, 堆, 直接内存 是JVM的内存主要划分区域!
    在这些内存的划分区域中 本地方法栈, Java虚拟机栈, 程序计数器 这三块区域中数据是随着方法的结束而消亡的, 因此不需要过多的考虑回收的问题!

对象的死活判定:
        判定对象是否存活和处理对象存活的过程 请观看 判定对象是否存活流程.jpg
        每个对象的判定死活的过程都至少经过两次标记过程 第一次: GCRoots 可达性策略, 第二次: 是否执行当前对象的finalize()方法 进行一次逃逸, 如果逃逸不了则进行二次标记

方法区中的垃圾回收:
    方法区中的垃圾往往分为两个部分: 不使用的常量 + 已经没有用的Klass类  这里的第二种情况中称之为 类型的卸载!
    判定方法区中某个常量死活 和 堆中对象的死活判定是一样的!

垃圾回收算法:
    弱分代假说
    强分代假说
    跨分代假说

垃圾回收常用名称词汇和含义:
    Minor GC/Young GC 新生代垃圾回收
    Major GC/Old GC   老年代垃圾回收
    Mixed GC 混合垃圾回收 (全部新生代 + 部分老年代的回收) 目前只有G1垃圾收集器 使用这种方式!
    Full GC  针对整个Java堆和方法区的回收

具体的垃圾回收算法:
    标记-清除算法     缺点: 随着堆区够大, 对象数量 和 标记-清除的时间 成正比; 容易产生大量的内存碎片!

    标记-复制算法     缺点: 初始设置为1:1的两块内存空间A和空间B, 先使用空间A,就空间A快使用完成时, 将存活的扔到空间B中 且将空间A直接干掉, 这样造成将近一半内存的浪费; 如果对象存活时间长则复制时间就会增多!

    标记-整理算法     由来: 标记-清除算法 随着类的增多效率会低 且会产生大量的碎片, 标记-复制算法 对于存活时间长的内存块来说这种不太适合且浪费了一半内存, 这样就催生出适用于老年代的一种 标记-整理算法
                 　　缺点: 针对老年代这种每次回收都会有很多存活的对象时, 移动存活对象的工作量是可想而知的 且 移动对象要格外的谨慎, 但是一旦移动就要停止目前所有的应用程序, 这个过程称之为 Stop The Word

从回收算法来说影响计算机吞吐量的两种最核心的部分: 内存的分配 + 内存的回收!
    内存如果在碎片中分配 则会影响创建对象时内存分配的效率, 如果在整块的连续内存中存储则效率更高!
    内存如果在碎片中清理 则会更加顺畅甚至停顿时间可以忽略不计, 如果标记-整理则会很耗性能!

    对于吞吐量来说 内存的分配 要 比垃圾回收 在吞吐量中的占比更高! 这里的吞吐量 = 赋值器 + 垃圾回收 中 赋值器的占比会上升!

不同垃圾回收算法为代表的 垃圾回收器
    标记-清除算法     因这种算法会产生内存碎片, 因此在分配对象时要困难一些, 因为内存的不连续性 这就要求要记录每个对象占用的内存碎片, 甚至随着时间的推移 所有可用内存碎片之和 不足以再次创建新的对象
                 　　CMS垃圾回收器就是采用的 标记-清除算法  Concurrent Mark Sweep

    标记-整理算法     Parallel Scavenge 则是采用的标记-整理算法!

    标记-复制算法

安全点和安全区: 在这个时间点上的GCRoots所判定的对象的死活全部是安全的!

记忆集:  记录非回收区域指向回收区域对象的指针的集合, 记忆集的三种维度 字长维度, 对象维度, 区域维度
        字长维度: 这块字长的内存区域中 含有跨代指针
        对象维度: 当前这个对象中有属性 含有跨代指针
        区域维度: 当前这块区域中有对象 含有跨带指针

跨代回收的处理:
    使用 记忆集的方法进行记录跨代引用, 达到GCRoots的精确定位, 防止死活判定的错误!

垃圾回收器   参考垃圾回收器.png

    Serial 新生代垃圾回收器
        采用标记-复制算法, 可与CMS垃圾回收器 进行配合, 客户端模式下的服务器 推荐使用

    ParNew 新生代垃圾回收器
        采用标记-复制算法, 可与CMS垃圾回收器 进行配合, 服务端模式下的服务器 推荐使用
        TODO 当开启CMS垃圾回收器时, 它为默认的新生代垃圾回收器, 开启CMS的VMOption为 -XX:+UseConcMarkSweepGC;
        如果强制 使用/关闭 这种新生代垃圾回收器 使用的VMOption 为 -XX:+/-UseParNewGC
        默认开启的收集线程数和处理器核心数量一致, 可以VMOption -XX:ParallelGCThreads 限制垃圾回收的线程数量 举例: -XX:ParallelGCThreads=1

    Parallel Scavenge 新生代垃圾回收器
        采用标记-复制算法, 前面的垃圾回收器的主要区别, 这种垃圾回收器注重垃圾回收时间的占比调控, 提高吞吐量
        吞吐量 = 用户代码执行时间 / (用户代码执行时间 + 垃圾回收时间)
        注意两个VMOption 的配置和含义
            -XX: MaxGCPauseMillis     含义: 每次完成GC的最大时间, 范围为 大于0的毫秒数, 切记这个不能随便乱用,
            举例: 原始 每10秒执行一次 每次执行时间为100ms, 现在改为 70ms了 但每5秒执行一次了, 时间是缩短了但频率增高了 造成最终吞吐量下降了!
            -XX: GCTimeRatio          含义: 垃圾回收器执行垃圾回收时间所占百分比 范围为 大于0小于100, 垃圾回收时间所占比例 = 1 / (1 + <GCTimeRatio>)

TODO 前面三款新生代的垃圾回收器 采用的都是 标记-复制算法

    Serial Old 垃圾收集器 主要针对的是 老年代的垃圾回收, 在老年代中采用的垃圾回收算法为 标记-整理 算法

    Parallel Old 垃圾收集器 这种垃圾收集器是 Parallel Scavenge 的老年代版本, 可以并行执行! 往往 和 Parallel Scavenge 配合使用

    CMS 垃圾收集器
        采用的是 标记-清除算法, 是一种以获取最短收集时间为目标的垃圾收集器, 目前很大一部分互联网架构模式是B/S模式的, 这种情况下 就要求响应时间越短越好, 往往采用这种垃圾回收器进行回收!
        CMS垃圾收集器 默认开启的收集线程数 = (处理器核数 + 3)/4, 因此这种情下 如果处理器核心数量为2 进行垃圾回收时, 就要分出一半的处理器进行垃圾回收, 因此在处理器核数非常少时要注意
        很多公司在垃圾回收时采用这种垃圾回收器, 采用的VMOption为 -XX:+UseConcMarkSweepGC 根据ParNew垃圾收集器中介绍, 新生代使用的默认垃圾收集器为ParNew

垃圾回收日志如何看:
    [GC (Allocation Failure) [PSYoungGen: 5632K->504K(6144K)] 5632K->1845K(19968K), 0.0049799 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
    [GC (Allocation Failure) [PSYoungGen: 5436K->488K(6144K)] 6777K->5743K(19968K), 0.0096965 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
    [GC (Allocation Failure) [PSYoungGen: 6120K->504K(6144K)] 11375K->10005K(19968K), 0.0551603 secs] [Times: user=0.00 sys=0.00, real=0.05 secs]
    [Full GC (Ergonomics) [PSYoungGen: 504K->0K(6144K)] [ParOldGen: 9501K->8641K(13824K)] 10005K->8641K(19968K), [Metaspace: 3231K->3231K(1056768K)], 0.2730018 secs] [Times: user=0.23 sys=0.00, real=0.27 secs]
    [Full GC (Ergonomics) [PSYoungGen: 5632K->1535K(6144K)] [ParOldGen: 11806K->13607K(13824K)] 17438K->15142K(19968K), [Metaspace: 3363K->3363K(1056768K)], 0.2896362 secs] [Times: user=0.42 sys=0.02, real=0.29 secs]
    [Full GC (Ergonomics) [PSYoungGen: 3152K->2933K(6144K)] [ParOldGen: 13607K->13606K(13824K)] 16759K->16540K(19968K), [Metaspace: 3363K->3363K(1056768K)], 0.2161645 secs] [Times: user=0.41 sys=0.00, real=0.22 secs]
    [Full GC (Allocation Failure) [PSYoungGen: 2933K->2933K(6144K)] [ParOldGen: 13606K->13588K(13824K)] 16540K->16522K(19968K), [Metaspace: 3363K->3363K(1056768K)], 0.2126162 secs] [Times: user=0.36 sys=0.00, real=0.21 secs]
    java.lang.OutOfMemoryError: Java heap space

    日志如何看以 第一行和最后一行为例来看
        [GC (Allocation Failure) 或 [Full GC (Allocation Failure) 解释如下:
            GC和Full GC 表示的是垃圾回收的停顿类型, Full GC 表示执行了 Stop The World; 接下来的括号 (Allocation Failure) 表示发生垃圾回收的原因;

        [PSYoungGen: 5632K->504K(6144K)] 解释如下:
            PSYoungGen      表示 Parallel Scavenge 进行的新生代垃圾回收, 这里切记对于不同的垃圾回收器 不同分代的叫法不一样;
            5632K->504K     表示 回收前本区域 使用容量 -> 回收后本区域 使用容量
            (6144K)         表示 本区域总容量

        5632K->1845K(19968K), 0.0049799 secs 解释如下:
            5632K->1845K    表示 堆区回收前的使用容量 -> 堆区回收后的使用容量
            (19968K)        表示 堆区总容量
            0.0049799 secs  表示 本区域GC占用时间

垃圾收集相关的参数配置
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    |          参数                                 |                                        描述                                                                                                                            |
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    |  -XX:+UseSerialGC                                        虚拟机运行在Client模式下的默认值, 打开此开关后, 将使用Serial + Serial Old 组合的垃圾回收器进行垃圾回收
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    |  -XX:+UseParNewGC                                        打开此开关后, 将使用ParNew + Serial Old 组合的垃圾回收器进行垃圾回收
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    |  -XX:+UseConcMarkSweepGC                                 打开此开关后, 将使用ParNew + CMS + Serial Old 组合的垃圾回收器进行垃圾回收, Serial Old 垃圾回收器作为 CMS收集器在 Concurrent Mode Failure 后的备用收集器
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
       -XX:+UseParallelGC                                      虚拟机运行在Server模式下的默认值, 打开此开关后, 将使用 Parallel Scavenge + Serial Old 组合的垃圾回收器进行垃圾回收

       -XX:+UseParallelOldGC                                   打开此开关后, 将使用Parallel Scavenge + Parallel Old 组合的垃圾回收器进行垃圾回收

       -XX:SurvivorRatio=8                                     新生代中 Eden区域 : Survivor区的比值, 默认值为8 代表Eden区占8, From Survivor区占1, To Survivor区占1

       -XX:PretenureSizeThreshold=<byte size>                  直接晋升到老年代的对象大小, 设置这个参数后, 大于这个参数的对象将直接在老年代中分配, 单位是字节; 默认值是0, 表示新生代中可以分配任意大小的对象

       -XX:MaxTenuringThreshold=0                              晋升到老年代对象的年龄, 当对象坚持过一次 Minor GC 年龄就 +1, 当新生代中对象的年龄 超过 这个配置值时, 就进入老年代中; 请注意，吞吐量收集器不使用 MaxTenuringThreshold 参数。

       -XX:+/-UseAdaptiveSizePolicy                            Parallel Scavenge 垃圾回收器使用, 开启这个开关后, 虚拟机将会自动调整 新生代, 老年代, 晋升老年代的年龄

       -XX:HandlePromotionFailure=true                         是否允许担保失败, 即老年代的剩余空间不足以应付新生代的整个 Eden 和 Survivor区中所有对象都能存活的极端情况, jdk7弃用了

       -XX:ParallelGCThreads=1                                 设置并行垃圾回收的线程数量

       -XX:GCTimeRatio=19                                      参考Parallel Scavenge 收集器中的介绍, 且只有

       -XX:MaxGCPauseMillis=100                                参考Parallel Scavenge 收集器中的介绍

       -XX:CMSInitiatingOccupancyFraction=92                   CMS垃圾收集器使用, 当老年代达到配置百分比时, 触发CMS垃圾回收。jdk5默认68%, jdk6提升至92%

       -XX:+UseCMSCompactAtFullCollection                      CMS垃圾收集器使用, 在CMS完成垃圾回收后是否要进行一次碎片整理默认为true

       -XX:CMSFullGCBeforeCompaction=0                         CMS垃圾收集器使用, 在上一次CMS并发GC执行过后，到底还要再执行多少次Full GC才会做压缩。默认是0 即默认完成一次Full GC 就进行一次碎片化整理


内存分配和回收策略:
    思维模型:
        我们关注内存的最核心的思想 就是如何完成内存的分配和回收, 来达到成功创建对象 并且 将其中已经判定死亡的对象所占用的内存 进行回收的过程!

    分配策略:
        对象优先在Eden区域分配
        大对象直接进入老年代            -XX:PretenureSizeThreshold=<byte-size>
        长期存活对象直接进入老年代       -XX:MaxTenuringThreshold=<熬过 MinorGC的次数>
        动态年龄的判定                 相同年龄为A 的 对象容量之和 大于 Survivor区域容量的一半, 则年龄大于等于A的所有对象 直接进入老年代
        空间分配担保机制               如果老年代剩余空间 大于新生代所有对象的总大小 或 大于历次晋升老年代的 对象总大小的平均值 则进行一次Minor GC 否则进行Full GC

-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------- 第四章 虚拟机性能监控和故障处理工具  -----------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
本章中的工具几乎都是基于 Windows平台下的jdk 进行讲解的!

jdk命令工具:
    0、top 作为辅助工具 记住可以切换为线程 快捷键 shift + h 或者 大写的H都可以, 如果查看完整命令 可以用 c 键来触发

    1、查看虚拟机进程工具 jps
        jps -l  : 查看各个进程启动类
        jps -v  : 查看各个进程的参数
        jps -m  : 查看main() 方法参数使用

    2、虚拟机统计信息 监视工具 jstat
        使用格式: jstat [ option vmid [interval [s | ms] [count]] ]
        使用案例: 查看进程1582 的垃圾回收信息, 每250ms 执行一次, 一共执行20次, jstat -gc 1582 250 20
        $jstat -gc 1582 1000
        S0C      S1C       S0U   S1U     EC        EU       OC          OU        MC       MU       CCSC    CCSU        YGC   YGCT    FGC    FGCT     GCT
        174720.0 174720.0  0.0   18254.5 1747712.0 101791.5 2097152.0   117569.4  254208.0 249583.1 31744.0 30734.8     41    1.658   0      0.000    1.658
        174720.0 174720.0  0.0   18254.5 1747712.0 102372.8 2097152.0   117569.4  254208.0 249583.1 31744.0 30734.8     41    1.658   0      0.000    1.658
        174720.0 174720.0  0.0   18254.5 1747712.0 102558.1 2097152.0   117569.4  254208.0 249583.1 31744.0 30734.8     41    1.658   0      0.000    1.658
        174720.0 174720.0  0.0   18254.5 1747712.0 102760.2 2097152.0   117569.4  254208.0 249583.1 31744.0 30734.8     41    1.658   0      0.000    1.658
        174720.0 174720.0  0.0   18254.5 1747712.0 102760.2 2097152.0   117569.4  254208.0 249583.1 31744.0 30734.8     41    1.658   0      0.000    1.658
        174720.0 174720.0  0.0   18254.5 1747712.0 102872.0 2097152.0   117569.4  254208.0 249583.1 31744.0 30734.8     41    1.658   0      0.000    1.658

        $jstat -gcutil 1582 1000
        S0    S1      E      O     M      CCS       YGC   YGCT      FGC  FGCT     GCT
        0.00  10.45   5.96   5.61  98.18  96.82     41    1.658     0    0.000    1.658
        0.00  10.45   6.08   5.61  98.18  96.82     41    1.658     0    0.000    1.658
        0.00  10.45   6.08   5.61  98.18  96.82     41    1.658     0    0.000    1.658
        0.00  10.45   6.08   5.61  98.18  96.82     41    1.658     0    0.000    1.658
        0.00  10.45   6.08   5.61  98.18  96.82     41    1.658     0    0.000    1.658
        0.00  10.45   6.10   5.61  98.18  96.82     41    1.658     0    0.000    1.658

    3、查看虚拟机配置信息工具 jinfo
        使用格式: jinfo [option] pid
        option : -flag
        替代方案: 在jdk6以后的替代方案为: -XX:+PrintFlagsFinal
        使用案例: jinfo -sysprops 1543, jinfo -flag name = value

    4、内存快照分析工具 jmap 是 java memory snapshot 的简称

    5、线程堆栈跟踪工具 jstack

    6、基础命令工具总结: 请查看 基础工具总结.png

图形化工具:
    1、HSDB
    2、JConsole
    3、VisualVM

-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------- 第五章 调优案例分析与实战  --------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
因前面通过学习 Java虚拟机的内存划分, OOM异常和垃圾回收策略, 常用的分析工具[命令工具和图文工具], 本章通过案例进行综合运用一下!

案例1:
    现状: 更换后的服务器和架构 16G内存, 64位操作系统, Centos5.4 B/S架构,
    解决: 大内存硬件上的部署策略, 拆分成多个虚拟机共同运行加上 Nginx 负载均衡的方式进行配置, 此为合理使用硬件系统! 清除时间更短的垃圾回收器CMS
         32位的寻址空间最大位4G, 因此一般 -Xmx1.5G
























































































